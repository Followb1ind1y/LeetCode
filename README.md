<p align="center">
<a href="https://github.com/Followb1ind1y"><img src="https://img.shields.io/static/v1?logo=github&label=maintainer&message=Followb1ind1y&color=eb5334" alt="Last Commit"/></a>
<a href="https://github.com/Followb1ind1y/LeetCode/graphs/commit-activity"><img src="https://img.shields.io/github/last-commit/Followb1ind1y/LeetCode.svg?colorB=eb9f34&style=flat" alt="Last Commit"/> </a>
<img src="https://img.shields.io/github/repo-size/Followb1ind1y/LeetCode.svg?colorB=34ebae&style=flat" alt="Size"/>
<img src="https://img.shields.io/github/languages/top/Followb1ind1y/LeetCode.svg?colorB=9f34eb&style=flat" alt="Language"/></a>
</p>

<p align="center">
<a href="https://mybinder.org/v2/gh/Followb1ind1y/LeetCode/HEAD"><img src="https://img.shields.io/badge/Open in-binder-579aca.svg?logo=data:image/png;base64,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" alt="binder"/></a>     
<a href="https://githubtocolab.com/Followb1ind1y/LeetCode"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="colab"/></a>       
</p>

# Machine Learning Engineer Interview Preparation Plan

## Basic Data Structures
### Study:
- **Arrays and Strings**: Understand how to manipulate arrays (e.g., resizing, iterating, filtering) and basic operations on strings (e.g., substring, concatenation, palindrome checking).
- **Linked Lists**: Learn the structure of single and doubly linked lists, and common operations such as insertion, deletion, searching, and reversing.
- **Stacks and Queues**: Understand the LIFO (Last In First Out) concept of stacks and the FIFO (First In First Out) concept of queues. Study their applications in solving problems like system navigation or printer task scheduling.

### Notes:
- **Arrays:**
In Python, arrays are typically represented using lists. While Python doesn't have a native array type as seen in other languages like Java or C++, lists are versatile and can be used similarly to arrays. 

ã€`Last Update: 2024-08-14`ã€‘
```
arr = []          # O(1)
arr = [1, 2, 3]   # O(n), where n is the number of elements
first_element = arr[0]  # O(1)
arr[1] = 10  # O(1)
arr.append(6)  # O(1) on average for appending
arr.insert(2, 15)  # O(n), where n is the number of elements after the insertion index
arr.remove(15)  # O(n), where n is the number of elements in the list [remove the first 15 in the array]
del arr[2]  # O(n), where n is the number of elements after the deleted index
last_element = arr.pop()  # O(1)
arr.sort()  # åŸåœ°æ’åº
sorted_arr = sorted(arr)  # è¿”å›æ’åºåçš„æ•°ç»„
arr[::-1] # arr å€’åº
```
```
## Counter() çš„å¸¸ç”¨è¯­æ³•å’Œä½¿ç”¨æƒ…å†µ
from collections import Counter
arr = [1, 2, 2, 3, 3, 3]
counts = Counter(arr)  # ç»“æœï¼šCounter({3: 3, 2: 2, 1: 1})

## æ‰¾åˆ°å‡ºç°æ¬¡æ•°æœ€å¤šçš„å…ƒç´ 
most_common_element = counts.most_common(1)[0]  # ç»“æœï¼š(3, 3)

## åˆ¤æ–­å‡ºç°çš„å…ƒç´ æ˜¯å¦ç›¸åŒ
arr1 = [1, 2, 3]
arr2 = [3, 2, 1]
is_anagram = Counter(arr1) == Counter(arr2)  # ç»“æœï¼šTrue
```
```
## set() çš„å¸¸ç”¨è¯­æ³•å’Œä½¿ç”¨æƒ…å†µ
arr = [1, 2, 2, 3, 4, 4]

## å¿«é€ŸæŸ¥æ‰¾
seen = set(arr)
if 3 in seen:
    print("3 is in array")

## å»é‡
unique_elements = list(set(arr))  # ç»“æœï¼š[1, 2, 3, 4]

## ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†
arr1 = [1, 2, 2, 3]
arr2 = [2, 3, 4]
intersection = list(set(arr1) & set(arr2))  # ç»“æœï¼š[2, 3]
```
- **Strings:**
Strings in Python are immutable sequences of characters. You can perform various operations on strings using built-in methods and operators.

ã€`Last Update: 2024-08-14`ã€‘
```
s = "Hello, World!"  # O(n), where n is the length of the string
first_char = s[0]  # O(1)
substring = s[7:12]  # O(k), where k is the length of the substring
combined = s + " Python"  # O(n + m), where n and m are the lengths of the two strings
repeated = s * 2  # O(n * k), where k is the number of repetitions

upper_s = s.upper()  # O(n), where n is the length of the string
lower_s = s.lower()  # O(n), where n is the length of the string
starts_with_hello = s.startswith("Hello")  # O(n), where n is the length of the prefix
contains_world = "World" in s  # O(n * m), where n is the length of the string and m is the length of the substring
replaced_s = s.replace("World", "Python")  # O(n * m), where n is the length of the string and m is the length of the substring

words = s.split(", ")  # O(n), where n is the length of the string
joined = " - ".join(words)  # O(n), where n is the total length of the resulting string
```

- **Linked Lists:**
A Linked List is a linear data structure consisting of nodes, where each node contains:

  * A data part that stores the actual data.
  * A next part (or pointer) that points to the next node in the list.

ã€`Last Update: 2024-11-14`ã€‘

```
## A node in a linked list can be represented as a class

class ListNode:
    def __init__(self, data=0, next=None):
        self.data = data  # Data of the node
        self.next = next  # Pointer to the next node
```
```
##  Inserting Nodes

def insert_at_beginning(head, data):
    new_node = ListNode(data)  # Create a new node
    new_node.next = head       # Link the new node to the current head
    return new_node            # New node becomes the head
```
```
## Deleting Nodes

def delete_from_beginning(head):
    if not head:
        return None
    return head.next  # The second node becomes the new head
```
```
## Searching for a Node

def search(head, key):
    current = head
    while current:
        if current.data == key:
            return True  # Found the data
        current = current.next
    return False  # Data not found
```
### Practice:
- [ ] Arrays and Strings:
  - [Two Sum - LeetCode 1](https://leetcode.com/problems/two-sum/)
  - [Valid Palindrome - LeetCode 125](https://leetcode.com/problems/valid-palindrome/)
- [ ] Linked Lists:
  - [Reverse Linked List - LeetCode 206](https://leetcode.com/problems/reverse-linked-list/)
  - [Linked List Cycle - LeetCode 141](https://leetcode.com/problems/linked-list-cycle/)
- [ ] Stacks and Queues:
  - [Valid Parentheses - LeetCode 20](https://leetcode.com/problems/valid-parentheses/)
  - [Implement Queue using Stacks - LeetCode 232](https://leetcode.com/problems/implement-queue-using-stacks/)

## Advanced Data Structures
### Study:
- **Trees**: Explore the concepts of binary trees, binary search trees, AVL trees, and tree traversals (in-order, pre-order, post-order, level-order).
- **Graphs**: Learn about different graph representations (adjacency list, adjacency matrix), and traversal algorithms (Depth-First Search, Breadth-First Search) to solve problems like finding connected components or checking cycles.
- **Hash Tables**: Study how hash tables work, including hashing functions, handling collisions, and applications in tasks like item counting or implementing dictionaries.

### Notes:
- **Hash Tables**:
In Python, the built-in dict type (short for dictionary) functions as a hash table. Hash tables are a key data structure used for efficient data retrieval and storage, providing average time complexities of O(1) for insertion, deletion, and lookup operations due to their underlying hashing mechanism.

ã€`Last Update: 2024-11-06`ã€‘

```
my_dict = {}  # Creating an empty dictionary
my_dict = {'key1': 'value1', 'key2': 'value2'}  # Creating a dictionary with initial values
value = my_dict['key1']   # Accessing a value by key
my_dict['key3'] = 'value3'  # Adding a new key-value pair
my_dict['key2'] = 'new_value2'  # Updating an existing key-value pair
del my_dict['key1']   # Removing an entry by key
value = my_dict.pop('key2')  # Popping an entry (removes and returns the value)
exists = 'key3' in my_dict  # # Checking if a key is in the dictionary [True]

for key in my_dict:
    print(key, my_dict[key]) # Iterating through keys
for key, value in my_dict.items(): # Iterating through key-value pairs
    print(key, value)
for value in my_dict.values(): # Iterating through values
    print(value)
```

```
# defaultdict ä½¿ç”¨æ–¹æ³•ï¼Œæ²¡è§è¿‡çš„å…ƒç´ ä¸ä¼šæŠ¥é”™ã€‚é€‚ç”¨äºè®¡æ•°ã€åˆ†ç»„å’ŒåµŒå¥—å­—å…¸ç­‰åº”ç”¨ã€‚

from collections import defaultdict

# ä½¿ç”¨ int ç±»å‹çš„ defaultdict
dd = defaultdict(int)
print(dd['missing_key'])  # è¾“å‡ºï¼š0ï¼Œå› ä¸º int() çš„é»˜è®¤å€¼æ˜¯ 0
print(dd)  # è¾“å‡ºï¼šdefaultdict(<class 'int'>, {'missing_key': 0})

# ç»Ÿè®¡å…ƒç´ å‡ºç°æ¬¡æ•°
data = "abracadabra"
counter = defaultdict(int)
for char in data:
    counter[char] += 1
print(counter)  # è¾“å‡ºï¼šdefaultdict(<class 'int'>, {'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1})

# defaultdict(list)å¸¸ç”¨äºå°†å¤šä¸ªå€¼å½’ç±»åˆ°åŒä¸€ä¸ªé”®ä¸‹ã€‚
data = [("apple", 1), ("banana", 2), ("apple", 3), ("banana", 4)]
grouped_data = defaultdict(list)
for fruit, count in data:
    grouped_data[fruit].append(count)
print(grouped_data)  # è¾“å‡ºï¼šdefaultdict(<class 'list'>, {'apple': [1, 3], 'banana': [2, 4]})

# å¯ä»¥ä½¿ç”¨dict()å°†defaultdictè½¬æ¢ä¸ºæ™®é€šå­—å…¸ã€‚
dd = defaultdict(int)
dd['a'] += 1
print(dict(dd))  # è¾“å‡ºï¼š{'a': 1}

```

### Practice:
- [ ] Trees:
  - [Binary Tree Inorder Traversal - LeetCode 94](https://leetcode.com/problems/binary-tree-inorder-traversal/)
  - [Lowest Common Ancestor of a Binary Search Tree - LeetCode 235](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)
- [ ] Graphs:
  - [Number of Islands - LeetCode 200](https://leetcode.com/problems/number-of-islands/)
  - [Course Schedule - LeetCode 207](https://leetcode.com/problems/course-schedule/)
- [ ] Hash Tables:
  - [Group Anagrams - LeetCode 49](https://leetcode.com/problems/group-anagrams/)
  - [Longest Consecutive Sequence - LeetCode 128](https://leetcode.com/problems/longest-consecutive-sequence/)

## Core Algorithms
### Study:
- **Two Pointer**: The two-pointer technique is used primarily in solving array and linked list problems. It involves using two pointers to traverse the data structure, allowing for efficient searching and processing of elements. 
- **Sorting Algorithms**: Review the mechanisms and use cases for quicksort, mergesort, and heapsort. Understand the trade-offs in terms of time and space complexity.
- **Search Algorithms**: Study binary search on sorted arrays, and learn about its variations for finding the first or last position of an element.
- **Recursion and Backtracking**: Understand how to apply recursion for solving problems involving permutations, combinations, and other backtrack-required scenarios. Study the call stack mechanism and how to optimize recursion through memoization.
- **Prefix Sum and Suffix Sum**: Prefix Sum and Suffix Sum are techniques used to compute the sum of elements in a subarray quickly by precomputing cumulative sums.

### Notes:
- **Two Pointer**:
  * Finding Pairs with a Given Sum: When looking for two numbers in a sorted array that add up to a specific target.
  * Reversing a String or Array: Using two pointers to swap elements from the start and end until they meet in the middle.
  * Merging Two Sorted Arrays: Traversing both arrays simultaneously to create a new sorted array.
  * Removing Duplicates from a Sorted Array: Using two pointers to track unique elements.
  * è®¾ç½® two pointers çš„æ—¶å€™ï¼Œleft ä¸€èˆ¬ä¼šåœ¨æœ€å‰é¢ï¼Œä½†æ˜¯ right ä¸ä¸€å®šåœ¨æœ€åï¼Œå¯ä»¥è®¾ç½®åœ¨ left åé¢ã€‚

ã€`Last Update: 2024-11-07`ã€‘

- **Prefix Sum and Suffix Sum**:
	1.	Prefix Sum: For an array nums, the prefix sum at each index i is the sum of all elements from the start of the array up to i. This allows you to find the sum of any subarray [i, j] in constant time by calculating prefix[j+1] - prefix[i].
	2.	Suffix Sum: For the same array nums, the suffix sum at index i is the sum of all elements from i to the end of the array. It enables efficient queries for sums of subarrays that start from any index i to a given end by using suffix[i] - suffix[j+1].

```
## Input [1, 2, 3, 4] -> Output [2x3x4, 1x3x4, 1x2x4, 1x2x3] = [24, 12, 8, 6]
## Predix -> [0, 1, 1x2, 1x2x3] = [0, 1, 2, 6]
## Suffix -> [2x3x4, 3x4, 4, 0] = [24, 12, 4, 0]

def productExceptSelf(self, nums: List[int]) -> List[int]:
  res = [1] * len(nums)
  prefix, suffix = 1, 1

  for i in range(len(nums)):
    res[i] = prefix
    prefix *= nums[i]

  for j in range(len(nums)-1,-1,-1):
    res[j] *= suffix
    suffix *= nums[j]
        
  return res
```
ã€`Last Update: 2024-11-11`ã€‘

### Practice:
- [ ] Sorting and Searching:
  - [Sort Colors - LeetCode 75](https://leetcode.com/problems/sort-colors/)
  - [Search in Rotated Sorted Array - LeetCode 33](https://leetcode.com/problems/search-in-rotated-sorted-array/)
- [ ] Recursion and Backtracking:
  - [Permutations - LeetCode 46](https://leetcode.com/problems/permutations/)
  - [N-Queens - LeetCode 51](https://leetcode.com/problems/n-queens/)

## Advanced Algorithms
### Study:
- **Dynamic Programming**: Explore the methodology of solving problems by breaking them down into smaller subproblems, storing results, and combining them to solve larger problems. Focus on understanding the concepts of overlapping subproblems and optimal substructure.
- **Greedy Algorithms**: Learn how greedy choices can lead to globally optimized solutions and their applications in problems like scheduling, graph based problems (like minimum spanning trees), and currency denomination.
- **Graph Algorithms**: Study shortest path algorithms (Dijkstraâ€™s, Bellman-Ford) and minimum spanning tree algorithms (Primâ€™s, Kruskalâ€™s). Understand their use cases and limitations.

### Notes:
-

### Practice:
- [ ] Dynamic Programming:
  - [Coin Change - LeetCode 322](https://leetcode.com/problems/coin-change/)
  - [Longest Increasing Subsequence - LeetCode 300](https://leetcode.com/problems/longest-increasing-subsequence/)
- [ ] Graph Algorithms:
  - [Network Delay Time (Dijkstra's Algorithm) - LeetCode 743](https://leetcode.com/problems/network-delay-time/)

## Special Topics Relevant to Machine Learning
### Study:
- **Geometric Algorithms**: Explore algorithms for computational geometry problems, such as finding the closest pair of points, checking point inclusion in a polygon, or computing the convex hull of a set of points.
- **Probabilistic Algorithms and Heuristics**: Learn about algorithms that incorporate randomness and probability, such as Monte Carlo methods and randomized optimization algorithms.
- **Advanced Data Structures for ML**: Dive into understanding more complex data structures like segment trees for range queries, Fenwick trees for cumulative frequency tables, and how they can be applied in machine learning contexts.

### Notes:
-

### Practice:
- [ ] Geometric and Probabilistic Algorithms:
  - [Max Points on a Line - LeetCode 149](https://leetcode.com/problems/max-points-on-a-line/)
  - [Linked List Random Node - LeetCode 382](https://leetcode.com/problems/linked-list-random-node/)
- [ ] Advanced Data Structures:
  - [Range Sum Query - Mutable (Segment Tree) - LeetCode 307](https://leetcode.com/problems/range-sum-query-mutable/)

<------------------------------------------------------------------------------------------------->
## **ç»ƒä¹ è®°å½•**
* `Date: 2024-11-06`:
  * [LeetCode 1 - Two Sum](https://leetcode.com/problems/two-sum/)ã€Arrayã€‘ã€Hash Tableã€‘
* `Date: 2024-11-07`:
  * [LeetCode 15 - 3 Sum](https://leetcode.com/problems/3sum/)ã€Arrayã€‘ã€Two Pointersã€‘
* `Date: 2024-11-08`:
  * [LeetCode 121 - Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)ã€Arrayã€‘ã€Dynamic Programmingã€‘
  * [LeetCode 349 - Intersection of Two Arrays](https://leetcode.com/problems/intersection-of-two-arrays/)ã€Arrayã€‘ã€Hash Tableã€‘
  * [LeetCode 219 - Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/)ã€Arrayã€‘ã€Hash Tableã€‘
* `Date: 2024-11-10`:
  * [Leetcode 454 - 4Sum II](https://leetcode.com/problems/4sum-ii/description/)ã€Arrayã€‘ã€Hash Tableã€‘
* `Date: 2024-11-11`:
  * [Leetcode 53 - Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/)ã€Arrayã€‘
  * [Leetcode 238 - Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/description)ã€Arrayã€‘ã€Prefix Sumã€‘
* `Date: 2024-11-12`:
  * [Leetcode 344 - Reverse String](https://leetcode.com/problems/reverse-string/description/)ã€Stringã€‘ã€Two Pointersã€‘
  * [Leetcode 26 - Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/)ã€Arrayã€‘ã€Two Pointersã€‘
  * [Leetcode 27 - Remove Element](https://leetcode.com/problems/remove-element/description)ã€Arrayã€‘ã€Two Pointersã€‘
* `Date: 2024-11-13`:
  * [Leetcode 3 - Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)ã€Stringã€‘ã€Hash Tableã€‘
  * [Leetcode 5 - Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/description/)ã€Stringã€‘ã€Two Pointersã€‘
  * [Leetcode 28 - Find the Index of the First Occurrence in a String](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)ã€Stringã€‘ã€Two Pointersã€‘
  * [Leetcode 49 - Group Anagrams](https://leetcode.com/problems/group-anagrams/description/)ã€Stringã€‘ã€Hash Tableã€‘
* `Date: 2024-11-14`:
  * [Leetcode 206 - Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/description/)ã€Linked Listã€‘ã€Recursionã€‘
* `Date: 2024-11-15`:
  * [Leetcode 21 - Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/description/)ã€Linked Listã€‘ã€Recursionã€‘
  * [Leetcode 141 - Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/description/)ã€Linked Listã€‘ã€Hash Tableã€‘
  * [Leetcode 203 - Remove Linked List Elements](https://leetcode.com/problems/remove-linked-list-elements/description/)ã€Linked Listã€‘ã€Recursionã€‘
  * [Leetcode 83 - Remove Duplicates from Sorted List](https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/)ã€Linked Listã€‘
  * [Leetcode 2 - Add Two Numbers](https://leetcode.com/problems/add-two-numbers/description)ã€Linked Listã€‘ã€Recursionã€‘ã€Mathã€‘
* `Date: 2024-11-17`:
  * [Leetcode 19 - Remove N-th Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/)ã€Linked Listã€‘ã€Two Pointersã€‘
  * [Leetcode 138 - Copy List with Random Pointer](https://leetcode.com/problems/copy-list-with-random-pointer/description/)ã€Linked Listã€‘ã€Hash Tableã€‘
  * [Leetcode 234 - Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/description)ã€Linked Listã€‘
  * [Leetcode 160 -  Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/description/)ã€Linked Listã€‘ã€Hash Tableã€‘
* `Date: 2024-11-18`:
  * [Leetcode 92 - Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/description/)ã€Linked Listã€‘
  * [Leetcode 61 - Rotate List](https://leetcode.com/problems/rotate-list/description)ã€Linked Listã€‘ã€Two Pointersã€‘
<------------------------------------------------------------------------------------------------->

# **LeetCode Problems' Solutions**
## Cheet Sheet
<details>
<summary>Numbers</summary>

  * **Python Arithmetic Operators**

  | Operator | Example |  Meaning |
  | --- | --- | --- |
  | `+` | 3 + 2 = 5 | Addition |
  | `-` |	3 - 2 = 1 | Subtraction |
  | `*` |	3 * 2 = 6 |	Multiplication |
  | `/` |	3 / 2 = 1.5 | Division |
  | `%` |	3 % 2 = 1 | Modulus |
  | `**` | 3 ** 2 = 9 | Exponentiation |
  | `//` | 5 // 2 = 2 | Floor division |
  | `math.sqrt()` | math.sqrt(4) = 2 | Square root |
  | `math.inf` | x = math.inf | Infinity |

  * **Python Bitwise Operators**

  | Operator | Example |  Meaning |
  | --- | --- | --- |
  | `&` | a & b | Bitwise AND |
  | `ï½œ` |	a ï½œ b |	Bitwise OR |
  | `^` |	a ^ b |	Bitwise XOR (exclusive OR) |
  | `~` |	~a |	Bitwise NOT |
  | `<<` |	a << n |	Bitwise left shift |
  | `>>` |	a >> n |	Bitwise right shift |

</details>

<details>
<summary>List</summary>

```python
List1 = [i for i in range(5)] # initialize list -> [0, 1, 2, 3, 4]
List2 = [0] * 5 # initialize list with 5 0's -> [0, 0, 0, 0, 0]
List1.append(-1) # -> [0, 1, 2, 3, 4, -1]
List1.sort() # -> [-1, 0, 1, 2, 3, 4]
List1.reverse() #-> [4, 3, 2, 1, 0, -1]
List3 = List1 + List2 # -> [4, 3, 2, 1, 0, -1, 0, 0, 0, 0, 0]
len(List3) # -> 11
List3.insert(11, 100) # -> [4, 3, 2, 1, 0, -1, 0, 0, 0, 0, 0, 100]
List3.pop() # -> [4, 3, 2, 1, 0, -1, 0, 0, 0, 0, 0]
List3.pop(1) # -> [4, 2, 1, 0, -1, 0, 0, 0, 0, 0]
List3.index(1) # -> 2
```

``` python
nums = [5, 4, 3, 2, 1]
nums.sort() # -> [1, 2, 3, 4, 5]
strings = ['Ford', 'BMW', 'Volvo']
strings.sort(key=lambda x: len(x) ) # -> ['BMW', 'Ford', 'Volvo']
lists = [[4,3], [5,5], [1,3]]
lists.sort(key=lambda x: x[0]) # -> [[1, 3], [4, 3], [5, 5]]
```
</details>

<details>
<summary>Dictionary</summary>

```python
d = {'key1': 'value1'} # Declare dict{'key1': 'value1'}
d['key2'] = 'value2' # Add Key and Value -> {'key1': 'value1', 'key2': 'value2'}
d['key1'] # Access value -> 'value1'
d.keys() # -> dict_keys(['key1', 'key2'])
d.values() # -> dict_values(['value1', 'value2'])
d.items() # -> dict_items([('key1', 'value1'), ('key2', 'value2')])
for k,v in d.items(): 
    print(k, v) # key1 value1 key2 value2
d.pop('key1') # -> 'value1'
d # -> {'key2': 'value2'}
```
</details>

<details>
  <summary>Strings</summary>

``` python
(ord("A"), ord("Z"), ord("a"), ord("z")) # (65, 90, 97, 122)
(chr(65), chr(90), chr(97), chr(122)) # ('A', 'Z', 'a', 'z')
"H/e/l/l/o".split("/") # ['H', 'e', 'l', 'l', 'o']
"/".join(['H', 'e', 'l', 'l', 'o']) # H/e/l/l/o
("a".upper(), "A".lower()) # ('A', 'a')
```
</details>

<details>
  <summary>Collections</summary>

* **collections.Counter()**
``` python
from collections import Counter

hashmap = collections.Counter("hello") # Counter({'h': 1, 'e': 1, 'l': 2, 'o': 1})
hashmap['l'] # 2
```
* **collections.deque()**
``` python
from collections import deque

deq = collections.deque([1, 2, 3]) # deque([1, 2, 3])
deq.appendleft(5) # deque([5, 1, 2, 3])
deq.append(6) # deque([5, 1, 2, 3, 6])
deq.popleft() # -> 5
deq.pop() # -> 6
```

* **collections.defaultdict()**
``` python
from collections import defaultdict

s = 'mississippi'
d = collections.defaultdict(int) # defaultdict(int, {})
for k in s:
    d[k] += 1
d # defaultdict(int, {'m': 1, 'i': 4, 's': 4, 'p': 2})
d.items() # dict_items([('m', 1), ('i', 4), ('s', 4), ('p', 2)])
```

``` python
from collections import defaultdict

s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
d = collections.defaultdict(list) # defaultdict(list, {})
for k, v in s:
    d[k].append(v)
d # defaultdict(list, {'yellow': [1, 3], 'blue': [2, 4], 'red': [1]})
d.items() # dict_items([('yellow', [1, 3]), ('blue', [2, 4]), ('red', [1])])
```

* **collections.OrderedDict()**
``` python
from collections import OrderedDict

hashmap = collections.OrderedDict.fromkeys("hello") 
# OrderedDict([('h', None), ('e', None), ('l', None), ('o', None)])
hashmap.popitem(last=True) # Returned in LIFO order if last is True -> ('o', None)
hashmap.popitem(last=False) # Returned in FIFO order if last is False -> ('h', None)
```

</details>

<details>
<summary>Stack</summary>

A **Stack** is a linear data structure that stores items in a **Last-In/First-Out (LIFO)** or **First-In/Last-Out (FILO)** manner. In stack, a new element is added at one end and an element is removed from that end only.

* `push(a)` â€“ Inserts the element â€˜aâ€™ at the top of the stack â€“ Time Complexity: O(1)
* `pop()` â€“ Deletes the topmost element of the stack â€“ Time Complexity: O(1)

<center><img src="https://drive.google.com/uc?export=view&id=12cKEW2XKl7tfO5ZH4FZ9-4TlFh3ST7ek" width=450px /></center>

```python
stack = []

stack.append('a') # append() function to push
stack.append('b') # element in the stack
stack.append('c') # -> ['a', 'b', 'c']

stack.pop() # -> 'c'
stack # -> ['a', 'b']
```

</details>

<details>
<summary>Queue</summary>

**Queue** is a linear data structure that stores items in **First In First Out (FIFO)** manner. With a queue the least recently added item is removed first. 

* `Enqueue`: Adds an item to the queue. If the queue is full, then it is said to be an Overflow condition â€“ Time Complexity : O(1)
* `Dequeue`: Removes an item from the queue. The items are popped in the same order in which they are pushed. If the queue is empty, then it is said to be an Underflow condition â€“ Time Complexity : O(1)

<center><img src="https://drive.google.com/uc?export=view&id=1QAw5MSmH_1DzY2wSKte6bLVKmWyUN0xF" width=450px /></center>

```python
queue = []

queue.append('a') # append() function to push
queue.append('b') # element in the stack
queue.append('c') # -> ['a', 'b', 'c']

queue.pop(0) # -> 'a'
queue # -> ['b', 'c']
```
* **Queue using Deque**

```python
from collections import deque

queue = deque(["Ram", "Tarun", "Asif", "John"])
queue.append("Akbar") # -> deque(['Ram', 'Tarun', 'Asif', 'John', 'Akbar'])
queue.popleft() # -> 'Ram'
queue # -> deque(['Tarun', 'Asif', 'John', 'Akbar'])                         
```
</details>

<details>
<summary>Deque</summary>

**Deque** or **Double Ended Queue** is a type of queue in which insertion and removal of elements can either be performed from the front or the rear. Thus, it does not follow FIFO rule (First In First Out).

<center><img src="https://drive.google.com/uc?export=view&id=1tnjr9gTLRVcQ0d1tnMEMuXQYOwMqlTWw" width=450px /></center>

``` python
from collections import deque

deq = collections.deque([1, 2, 3]) # deque([1, 2, 3])
deq.appendleft(5) # deque([5, 1, 2, 3])
deq.append(6) # deque([5, 1, 2, 3, 6])
deq.popleft() # -> 5
deq.pop() # -> 6
```


</details>

<details>
  <summary>Binary Tree</summary>
<p align="center">
<img src="Tree/img/LeetCode0094_Preorder-from-Inorder-and-Postorder-traversals.jpg" width="500">
</p>
</details>

<details>
  <summary>Graph</summary>

``` python
N = 6
edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]
graph = [[] for _ in range(N)]
for u,v in edges:
    graph[u].append(v)
    graph[v].append(u)
graph # -> [[1, 2], [0], [0, 3, 4, 5], [2], [2], [2]]
```
</details>

<details>
  <summary>Algorithms</summary>

* **Binary Search**
``` python
# Runtime complexity : O(log n)

def binary_search(self, nums: List[int], target: int) -> int:
    left, right = 0, len(nums) - 1
    
    while(left <= right):
        center = (left + right) // 2
        if nums[center] == target:
            return center
        elif nums[center] < target:
            left = center + 1
        else:
            right = center - 1
    
    return -1
```
</details>

## **Array**
* [11. Container With Most Water [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Array/0011_Container_With_Most_Water.md)
* [31. Next Permutation [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Array/0031_Next_Permutation.md) ğŸ”¥
* [42. Trapping Rain Water [Hard]](https://github.com/Followb1ind1y/LeetCode/blob/main/Array/0042_Trapping_Rain_Water.md)
* [134. Gas Station [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Array/0134_Gas_Station.md)
* [150. Evaluate Reverse Polish Notation [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Array/0150_Evaluate_Reverse_Polish_Notation.md)

## **Backtracking**
* [39. Combination Sum [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Backtracking/0039_Combination_Sum.md)
* [46. Permutations [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Backtracking/0046_Permutations.md) ğŸ”¥
* [51. N-Queens [Hard]](https://github.com/Followb1ind1y/LeetCode/blob/main/Backtracking/0051_N-Queens.md)
* [79. Word Search [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Backtracking/0079_Word_Search.md)

## **Binary Search**
* [33. Search in Rotated Sorted Array [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Binary_Search/0033_Search_in_Rotated_Sorted_Array.md) ğŸ”¥
* [74. Search a 2D Matrix [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Binary_Search/0074_Search_a_2D_Matrix.md)
* [153. Find Minimum in Rotated Sorted Array [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Binary_Search/0153_Find_Minimum_in_Rotated_Sorted_Array.md)

## **Bit Manipulation**
* [89. Gray Code [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Bit_Manipulation/0089_Gray_Code.md)
* [191. Number of 1 Bits [Easy]](https://github.com/Followb1ind1y/LeetCode/blob/main/Bit_Manipulation/0191_Number_of_1_Bits.md)
* [461. Hamming Distance [Easy]](https://github.com/Followb1ind1y/LeetCode/blob/main/Bit_Manipulation/0461_Hamming_Distance.md) ğŸ”¥

## **Dynamic Programming**
* [22. Generate Parentheses [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Dynamic_Programming/0022_Generate_Parentheses.md) ğŸ”¥
* [45. Jump Game II [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Dynamic_Programming/0045_Jump_Game_II.md)
* [62. Unique Paths [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Dynamic_Programming/0062_Unique_Paths.md) ğŸ”¥
* [91. Decode Ways [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Dynamic_Programming/0091_Decode_Ways.md) ğŸ”¥
* [122. Best Time to Buy and Sell Stock II [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Dynamic_Programming/0122_Best_Time_to_Buy_and_Sell_Stock_II.md)

## **Graph**
* [133. Clone Graph [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Graph/0133_Clone_Graph.md)
* [138. Copy List with Random Pointer [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Graph/0138_Copy_List_with_Random_Pointer.md)
* [207. Course Schedule [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Graph/0207_Course_Schedule.md)

## **Linked List**
* [2. Add Two Numbers [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Linked_List/0002_Add_Two_Numbers.md)
* [21. Merge Two Sorted Lists [Easy]](https://github.com/Followb1ind1y/LeetCode/blob/main/Linked_List/0021_Merge_Two_Sorted_Lists.md)
* [23. Merge k Sorted Lists [Hard]](https://github.com/Followb1ind1y/LeetCode/blob/main/Linked_List/0023_Merge_k_Sorted_Lists.md) ğŸ”¥
* [24. Swap Nodes in Pairs [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Linked_List/0024_Swap_Nodes_in_Pairs.md)
* [86. Partition List [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Linked_List/0086_Partition_List.md)
* [143. Reorder List [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Linked_List/0143_Reorder_List.md)
* [146. LRU Cache [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Linked_List/0146_LRU_Cache.md) ğŸ”¥
* [148. Sort List [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Linked_List/0148_Sort_List.md)
* [206. Reverse Linked List [Easy]](https://github.com/Followb1ind1y/LeetCode/blob/main/Linked_List/0206_Reverse_Linked_List.md) ğŸ”¥
* [445. Add Two Numbers II [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Linked_List/0445_Add_Two_Numbers_II.md)

## **Math**
* [7. Reverse Integer [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Math/0007_Reverse_Integer.md)
* [149. Max Points on a Line [Hard]](https://github.com/Followb1ind1y/LeetCode/blob/main/Math/0149_Max_Points_on_a_Line.md)

## **Matrix**
* [36. Valid Sudoku [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Matrix/0036_Valid_Sudoku.md)
* [48. Rotate Image [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Matrix/0048_Rotate_Image.md) ğŸ”¥

## **Sorting**
* [15. 3Sum [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Sorting/0015_3Sum.md)
* [16. 3Sum Closest [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Sorting/0016_3Sum_Closest.md)
* [56. Merge Intervals [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Sorting/0056_Merge_Intervals.md) ğŸ”¥
* [75. Sort Colors [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Sorting/0075_Sort_Colors.md) ğŸ”¥
* [169. Majority Element [Easy]](https://github.com/Followb1ind1y/LeetCode/blob/main/Sorting/0169_Majority_Element.md)

## **String**
* [3. Longest Substring Without Repeating Characters [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/String/0003_Longest_Substring_Without_Repeating_Characters.md)
* [5. Longest Palindromic Substring [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/String/0005_Longest_Palindromic_Substring.md) ğŸ”¥
* [68. Text Justification [Hard]](https://github.com/Followb1ind1y/LeetCode/blob/main/String/0068_Text_Justification.md)
* [71. Simplify Path [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/String/0071_Simplify_Path.md) ğŸ”¥
* [76. Minimum Window Substring [Hard]](https://github.com/Followb1ind1y/LeetCode/blob/main/String/0076_Minimum_Window_Substring.md) ğŸ”¥
* [139. Word Break [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/String/0139_Word_Break.md)

## **Tree**
* [94. Binary Tree Inorder Traversal [Easy]](https://github.com/Followb1ind1y/LeetCode/blob/main/Tree/0094_Binary_Tree_Inorder_Traversal.md) ğŸ”¥
* [95. Unique Binary Search Trees II [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Tree/0095_Unique_Binary_Search_Trees_II.md) ğŸ”¥
* [98. Validate Binary Search Tree [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Tree/0098_Validate_Binary_Search_Tree.md)
* [105. Construct Binary Tree from Preorder and Inorder Traversal [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Tree/0105_Construct_Binary_Tree_from_Preorder_and_Inorder_Traversal.md)
* [109. Convert Sorted List to Binary Search Tree [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Tree/0109_Convert_Sorted_List_to_Binary_Search_Tree.md) ğŸ”¥
* [114. Flatten Binary Tree to Linked List [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Tree/0114_Flatten_Binary_Tree_to_Linked_List.md)
* [116. Populating Next Right Pointers in Each Node [Medium]](https://github.com/Followb1ind1y/LeetCode/blob/main/Tree/0116_Populating_Next_Right_Pointers_in_Each_Node.md)
* [124. Binary Tree Maximum Path Sum [Hard]](https://github.com/Followb1ind1y/LeetCode/blob/main/Tree/0124_Binary_Tree_Maximum_Path_Sum.md) ğŸ”¥

## **To-do List**
* [10. Regular Expression Matching [Hard]](https://leetcode.com/problems/regular-expression-matching/)
* [25. Reverse Nodes in k-Group [Hard]](https://leetcode.com/problems/reverse-nodes-in-k-group/)
* [44. Wildcard Matching [Hard]](https://leetcode.com/problems/wildcard-matching/)
* [84. Largest Rectangle in Histogram [Hard]](https://leetcode.com/problems/largest-rectangle-in-histogram/)
* [115. Distinct Subsequences [Hard]](https://leetcode.com/problems/distinct-subsequences/)
* [126. Word Ladder II [Hard]](https://leetcode.com/problems/word-ladder-ii/)
* [132. Palindrome Partitioning II [Hard]](https://leetcode.com/problems/palindrome-partitioning-ii/)